---
layout: essay
type: essay
title: "ChatGPT Is a Productivity Powerhouse"
# All dates must be YYYY-MM-DD format!
date: 2024-12-17
published: true
labels:
  - Generative AI
  - Productivity
  - Web Development
---

<img width="100%" class="rounded float-start pe-4" src="../img/chatgpt.jpg">

# I. Introduction
AI has been a game-changer in tech, education, and especially for computer science students like me. It's like having an unpaid intern who's always there to help with tedious tasks you aren't willing to do. So far, I've only tried AI models from OpenAI, like GPT-4o and GPT-o1, but they have been a huge boost to my productivity. Mainly, I use AI to bring my ideas to life, which gives me more time to focus on problem-solving.

# II. Personal Experience with AI

## 1. Experience WODs e.g. E18
In Experience WOD E18, I chose not to use AI because the task was straightforward and only required a basic implementation of a forEach loop and conditional statements. Using AI would have likely taken me longer, as I would need to spend additional time writing prompts and providing the necessary context.

## 2. In-Class Practice WODs
For the in-class practice WODs, I chose not to use AI because I viewed them as an opportunity to better understand development concepts. Additionally, since the WODs were not graded and had no time constraints, there was no pressure to complete them quickly.

## 3. In-Class WODs
For in-class WODs, I chose not to use AI for the same reason I avoided it during practice WODs. I viewed them as an opportunity to better understand development concepts. Additionally, time constraints were never an issue for me, as I consistently finished well within the allotted time, and often using less than half of it.

## 4. Essays
For essays, I begin by jotting down all my thoughts, even if the grammar is incorrect or the sentence structure is messy. Once everything is written, I use ChatGPT to correct grammar and refine the sentence structure, in order to ensure the final version sounds more formal and polished. For instance, I might prompt the AI with something like, "Improve and correct the grammar for this: XXXXX."

## 5. Final Project
For my final project, I used ChatGPT to handle tedious tasks, such as generating HTML code for a layout. I would prompt the AI with requests like, "Can you add an extra field to this form?" or "Move the button to the left," while providing the code I was working on. This eliminated the need for me to write boilerplate code and allowed me to focus on the project's logical components. By reducing the time spent on creating the layout from scratch, I was able to dedicate more time to other tasks which significantly speed up the development process.

## 6. Learning a Concept / Tutorial
When learning a new concept or following a tutorial, I prefer referring to official documentation rather than relying on AI tools like ChatGPT. I find that AI often provides inaccurate or outdated information, which can sometimes be unhelpful. Additionally, official documentation tends to be more concise and easier to read compared to the lengthy and sometimes redundant explanations generated by ChatGPT.

## 7. Answering a Question in Class or in Discord
When answering questions in class, I avoid using AI because it doesn’t help me truly learn or engage with the material. The purpose of the professor's questions is to assess our understanding, not our ability to consult a chatbot and recite its answers.

## 8. Asking or Answering a Smart-Question
When writing questions or answers, I often use ChatGPT to check for grammar errors and improve sentence structure to ensures my message is clear so it is easy for others to understand. For instance, I might prompt the AI with something like, "Improve and correct the grammar for this: XXXXX."

## 9. Coding Example
When searching for coding examples, I usually start with online documentation. However, if the specific example I need isn’t available, I turn to ChatGPT as a last resort. Occasionally, if the documentation provides examples that lacks detailed explanations, I ask ChatGPT to explain and help me understand how the example from the documentation works.

## 10. Explaining Code
As mentioned earlier, if I don’t understand how a part of the code works, I use ChatGPT to provide an overall breakdown of each component with prompts like, "Explain `CODE_HERE`." If there’s a specific part I still don’t understand, I follow up with more targeted prompts such as, "Can you explain this line: `CODE_HERE`."

## 11. Writing Code
For simple helper functions, I usually delegate the task to ChatGPT, which allows me to focus on designing the overall component code. For instance, if I need a helper function to check whether all fields in a form are filled, I might prompt ChatGPT with something like: "Write a helper function that checks if all fields are filled and attach it to the disabled property of the button in the form. Here is the code: `CODE_HERE`."

## 12. Documenting code
Just like when I write essays, I start by writing everything myself and then ask ChatGPT to refine it for me.

## 13. Quality Assurance
When I write a function or code myself, I review it by providing ChatGPT with the context in which the function is used and asking it to check if the implementation covers all possible cases to catch potential bugs. For example, I might prompt ChatGPT with: "This is the context: XXXXX. Are there any issues with the function implementation?"

# III. Impact on Learning and Understanding
For me, AI lowers the barrier for programmers to write code in any language. While AI may not excel at writing complete application codebases, it is an excellent tool for bringing a programmer's ideas to life. With AI, programmers can focus more on understanding the conceptual and theoretical aspects of computer science rather than spending excessive time on syntax and troubleshooting. This allows me to dedicate more time to problem-solving and deepening my understanding of development concepts. However, relying too much on AI to bypass the troubleshooting process could hinder the development of critical problem-solving skills for me and other students, which might become a challenge later on as software developers.

# IV. Practical Applications
Generative AI can serve as a temporary replacement for algorithms in certain scenarios. For instance, during a project in HACC, I needed to implement a function that analyzed columns in a unique CSV dataset to determine which could be used as the x and y axes for visualizing the data. Instead of spending significant time developing an algorithm to determine this programmatically, I used the OpenAI GPT API to handle the task. This approach saved a considerable amount of development time, allowing us to focus on other features of our application. In conclusion, I believe generative AI tools like ChatGPT are excellent substitutes for algorithms when rapid development is a priority.

# V. Challenges and Opportunities
For the Digits or Next.js application tutorial, I struggled to provide AI or ChatGPT with the correct context for the issues I faced, as a Next.js application is significantly more complex. As a result, ChatGPT wasn’t very helpful in that situation because I had nothing to reference apart from the tutorial page. I believe it would be incredibly useful to have a ChatGPT assistant specifically tailored to the teaching material, as it would already have the context of what students are working on. This would eliminate the need to constantly copy and pasting code or switch tabs just to provide sufficient context for ChatGPT to offer a helpful response. 

# VI. Comparative Analysis
Traditional teaching in software engineering, while effective in providing students with a strong foundational knowledge, can sometimes feel too rigid and may not suit everyone's learning pace. AI tools, on the other hand, make learning more flexible by offering instant feedback and personalized assistance. AI-enhanced learning also helps students save time on repetitive tasks, allowing them to focus more on problem-solving. However, excessive reliance on AI could hinder the development of critical thinking skills and reduce hands-on experience with writing and debugging code.

# VII. Future Considerations